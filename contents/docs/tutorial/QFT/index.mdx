---
title: QFT
description: This section provides an overview of the Quantum Fourier Transform (QFT) in the LogosQ Library.
---

# Quantum Fourier Transform (QFT)

## Mathematical Definition

The Quantum Fourier Transform is defined as the following unitary transformation on the computational basis states:

<BlockMath math="|j\rangle \mapsto \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} e^{2\pi ijk/N} |k\rangle" />

Where:
- N = 2^n for an n-qubit system
- j and k are integers from 0 to N-1
- <InlineMath math="e^{2\pi ijk/N}" /> represents the complex phase factor

For a general quantum state <InlineMath math="|\psi\rangle = \sum_{j=0}^{N-1} \alpha_j |j\rangle" />, the QFT produces:

<BlockMath math="QFT|\psi\rangle = \sum_{j=0}^{N-1} \alpha_j \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} e^{2\pi ijk/N} |k\rangle" />

This can be rewritten as:

<BlockMath math="QFT|\psi\rangle = \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \left(\sum_{j=0}^{N-1} \alpha_j e^{2\pi ijk/N}\right) |k\rangle" />

The QFT is the quantum analog of the discrete Fourier transform, performing a basis transformation from the computational basis to the Fourier basis.

## Implementation in LogosQ

The LogosQ library provides a built-in function to perform the Quantum Fourier Transform on a quantum circuit. The function can be applied to a specified range of qubits within the circuit.

```rust
use logosq::algorithms::qft;
use logosq::circuits::Circuit;
use logosq::vis::circuit_text;
use logosq::vis::save_circuit_svg;
use logosq::vis::Visualizable;
use logosq::State;

fn main() {
    let num_qubits = 5; // Example with 5 qubits
    let results = quantum_fourier_transform_example(num_qubits);
    println!("Measurement results after QFT: {:?}", results);
}
// how to combine algorithms
pub fn quantum_fourier_transform_example(num_qubits: usize) -> Vec<usize> {

    let mut state = State::zero_state(num_qubits);
    // Create a circuit that demonstrates QFT
    let mut circuit = Circuit::new(num_qubits);
    circuit.x(0);
    circuit.execute(&mut state);

    // Apply QFT
    qft::apply(&mut state);
    print!("State after QFT: {}\n", state.visualize());
    qft::apply_inverse(&mut state);
    print!("State after inverse QFT: {}\n", state.visualize());
    circuit.execute_and_measure()
}
```